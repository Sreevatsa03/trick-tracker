{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar events_1 = require(\"events\");\nvar tools = require(\"./tools\");\n/**\n * This is an informal code for reference.\n * EBMLReader is a class for getting information to enable seeking Webm recorded by MediaRecorder.\n * So please do not use for regular WebM files.\n */\nvar EBMLReader = function (_super) {\n  __extends(EBMLReader, _super);\n  function EBMLReader() {\n    var _this = _super.call(this) || this;\n    _this.logGroup = \"\";\n    _this.hasLoggingStarted = false;\n    _this.metadataloaded = false;\n    _this.chunks = [];\n    _this.stack = [];\n    _this.segmentOffset = 0;\n    _this.last2SimpleBlockVideoTrackTimecode = [0, 0];\n    _this.last2SimpleBlockAudioTrackTimecode = [0, 0];\n    _this.lastClusterTimecode = 0;\n    _this.lastClusterPosition = 0;\n    _this.timecodeScale = 1000000; // webm default TimecodeScale is 1ms\n    _this.metadataSize = 0;\n    _this.metadatas = [];\n    _this.cues = [];\n    _this.firstVideoBlockRead = false;\n    _this.firstAudioBlockRead = false;\n    _this.currentTrack = {\n      TrackNumber: -1,\n      TrackType: -1,\n      DefaultDuration: null,\n      CodecDelay: null\n    };\n    _this.trackTypes = [];\n    _this.trackDefaultDuration = [];\n    _this.trackCodecDelay = [];\n    _this.trackInfo = {\n      type: \"nothing\"\n    };\n    _this.ended = false;\n    _this.logging = false;\n    _this.use_duration_every_simpleblock = false;\n    _this.use_webp = false;\n    _this.use_segment_info = true;\n    _this.drop_default_duration = true;\n    return _this;\n  }\n  /**\n   * emit final state.\n   */\n  EBMLReader.prototype.stop = function () {\n    this.ended = true;\n    this.emit_segment_info();\n    // clean up any unclosed Master Elements at the end of the stream.\n    while (this.stack.length) {\n      this.stack.pop();\n      if (this.logging) {\n        console.groupEnd();\n      }\n    }\n    // close main group if set, logging is enabled, and has actually logged anything.\n    if (this.logging && this.hasLoggingStarted && this.logGroup) {\n      console.groupEnd();\n    }\n  };\n  /**\n   * emit chunk info\n   */\n  EBMLReader.prototype.emit_segment_info = function () {\n    var data = this.chunks;\n    this.chunks = [];\n    if (!this.metadataloaded) {\n      this.metadataloaded = true;\n      this.metadatas = data;\n      var videoTrackNum = this.trackTypes.indexOf(1); // find first video track\n      var audioTrackNum = this.trackTypes.indexOf(2); // find first audio track\n      this.trackInfo = videoTrackNum >= 0 && audioTrackNum >= 0 ? {\n        type: \"both\",\n        trackNumber: videoTrackNum\n      } : videoTrackNum >= 0 ? {\n        type: \"video\",\n        trackNumber: videoTrackNum\n      } : audioTrackNum >= 0 ? {\n        type: \"audio\",\n        trackNumber: audioTrackNum\n      } : {\n        type: \"nothing\"\n      };\n      if (!this.use_segment_info) {\n        return;\n      }\n      this.emit(\"metadata\", {\n        data: data,\n        metadataSize: this.metadataSize\n      });\n    } else {\n      if (!this.use_segment_info) {\n        return;\n      }\n      var timecode = this.lastClusterTimecode;\n      var duration = this.duration;\n      var timecodeScale = this.timecodeScale;\n      this.emit(\"cluster\", {\n        timecode: timecode,\n        data: data\n      });\n      this.emit(\"duration\", {\n        timecodeScale: timecodeScale,\n        duration: duration\n      });\n    }\n  };\n  EBMLReader.prototype.read = function (elm) {\n    var _this = this;\n    var drop = false;\n    if (this.ended) {\n      // reader is finished\n      return;\n    }\n    if (elm.type === \"m\") {\n      // 閉じタグの自動挿入\n      if (elm.isEnd) {\n        this.stack.pop();\n      } else {\n        var parent_1 = this.stack[this.stack.length - 1];\n        if (parent_1 != null && parent_1.level >= elm.level) {\n          // 閉じタグなしでレベルが下がったら閉じタグを挿入\n          this.stack.pop();\n          // From http://w3c.github.io/media-source/webm-byte-stream-format.html#webm-media-segments\n          // This fixes logging for webm streams with Cluster of unknown length and no Cluster closing elements.\n          if (this.logging) {\n            console.groupEnd();\n          }\n          parent_1.dataEnd = elm.dataEnd;\n          parent_1.dataSize = elm.dataEnd - parent_1.dataStart;\n          parent_1.unknownSize = false;\n          var o = Object.assign({}, parent_1, {\n            name: parent_1.name,\n            type: parent_1.type,\n            isEnd: true\n          });\n          this.chunks.push(o);\n        }\n        this.stack.push(elm);\n      }\n    }\n    if (elm.type === \"m\" && elm.name == \"Segment\") {\n      if (this.segmentOffset != 0) {\n        console.warn(\"Multiple segments detected!\");\n      }\n      this.segmentOffset = elm.dataStart;\n      this.emit(\"segment_offset\", this.segmentOffset);\n    } else if (elm.type === \"b\" && elm.name === \"SimpleBlock\") {\n      var _a = tools.ebmlBlock(elm.data),\n        timecode = _a.timecode,\n        trackNumber = _a.trackNumber,\n        frames_1 = _a.frames;\n      if (this.trackTypes[trackNumber] === 1) {\n        if (!this.firstVideoBlockRead) {\n          this.firstVideoBlockRead = true;\n          if (this.trackInfo.type === \"both\" || this.trackInfo.type === \"video\") {\n            var CueTime = this.lastClusterTimecode + timecode;\n            this.cues.push({\n              CueTrack: trackNumber,\n              CueClusterPosition: this.lastClusterPosition,\n              CueTime: CueTime\n            });\n            this.emit(\"cue_info\", {\n              CueTrack: trackNumber,\n              CueClusterPosition: this.lastClusterPosition,\n              CueTime: this.lastClusterTimecode\n            });\n            this.emit(\"cue\", {\n              CueTrack: trackNumber,\n              CueClusterPosition: this.lastClusterPosition,\n              CueTime: CueTime\n            });\n          }\n        }\n        this.last2SimpleBlockVideoTrackTimecode = [this.last2SimpleBlockVideoTrackTimecode[1], timecode];\n      } else if (this.trackTypes[trackNumber] === 2) {\n        if (!this.firstAudioBlockRead) {\n          this.firstAudioBlockRead = true;\n          if (this.trackInfo.type === \"audio\") {\n            var CueTime = this.lastClusterTimecode + timecode;\n            this.cues.push({\n              CueTrack: trackNumber,\n              CueClusterPosition: this.lastClusterPosition,\n              CueTime: CueTime\n            });\n            this.emit(\"cue_info\", {\n              CueTrack: trackNumber,\n              CueClusterPosition: this.lastClusterPosition,\n              CueTime: this.lastClusterTimecode\n            });\n            this.emit(\"cue\", {\n              CueTrack: trackNumber,\n              CueClusterPosition: this.lastClusterPosition,\n              CueTime: CueTime\n            });\n          }\n        }\n        this.last2SimpleBlockAudioTrackTimecode = [this.last2SimpleBlockAudioTrackTimecode[1], timecode];\n      }\n      if (this.use_duration_every_simpleblock) {\n        this.emit(\"duration\", {\n          timecodeScale: this.timecodeScale,\n          duration: this.duration\n        });\n      }\n      if (this.use_webp) {\n        frames_1.forEach(function (frame) {\n          var startcode = frame.slice(3, 6).toString(\"hex\");\n          if (startcode !== \"9d012a\") {\n            return;\n          }\n          ; // VP8 の場合\n          var webpBuf = tools.VP8BitStreamToRiffWebPBuffer(frame);\n          var webp = new Blob([webpBuf], {\n            type: \"image/webp\"\n          });\n          var currentTime = _this.duration;\n          _this.emit(\"webp\", {\n            currentTime: currentTime,\n            webp: webp\n          });\n        });\n      }\n    } else if (elm.type === \"m\" && elm.name === \"Cluster\" && elm.isEnd === false) {\n      this.firstVideoBlockRead = false;\n      this.firstAudioBlockRead = false;\n      this.emit_segment_info();\n      this.emit(\"cluster_ptr\", elm.tagStart);\n      this.lastClusterPosition = elm.tagStart;\n    } else if (elm.type === \"u\" && elm.name === \"Timecode\") {\n      this.lastClusterTimecode = elm.value;\n    } else if (elm.type === \"u\" && elm.name === \"TimecodeScale\") {\n      this.timecodeScale = elm.value;\n    } else if (elm.type === \"m\" && elm.name === \"TrackEntry\") {\n      if (elm.isEnd) {\n        this.trackTypes[this.currentTrack.TrackNumber] = this.currentTrack.TrackType;\n        this.trackDefaultDuration[this.currentTrack.TrackNumber] = this.currentTrack.DefaultDuration;\n        this.trackCodecDelay[this.currentTrack.TrackNumber] = this.currentTrack.CodecDelay;\n      } else {\n        this.currentTrack = {\n          TrackNumber: -1,\n          TrackType: -1,\n          DefaultDuration: null,\n          CodecDelay: null\n        };\n      }\n    } else if (elm.type === \"u\" && elm.name === \"TrackType\") {\n      this.currentTrack.TrackType = elm.value;\n    } else if (elm.type === \"u\" && elm.name === \"TrackNumber\") {\n      this.currentTrack.TrackNumber = elm.value;\n    } else if (elm.type === \"u\" && elm.name === \"CodecDelay\") {\n      this.currentTrack.CodecDelay = elm.value;\n    } else if (elm.type === \"u\" && elm.name === \"DefaultDuration\") {\n      // media source api は DefaultDuration を計算するとバグる。\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=606000#c22\n      // chrome 58 ではこれを回避するために DefaultDuration 要素を抜き取った。\n      // chrome 58 以前でもこのタグを抜き取ることで回避できる\n      if (this.drop_default_duration) {\n        console.warn(\"DefaultDuration detected!, remove it\");\n        drop = true;\n      } else {\n        this.currentTrack.DefaultDuration = elm.value;\n      }\n    } else if (elm.name === \"unknown\") {\n      console.warn(elm);\n    }\n    if (!this.metadataloaded && elm.dataEnd > 0) {\n      this.metadataSize = elm.dataEnd;\n    }\n    if (!drop) {\n      this.chunks.push(elm);\n    }\n    if (this.logging) {\n      this.put(elm);\n    }\n  };\n  Object.defineProperty(EBMLReader.prototype, \"duration\", {\n    /**\n     * DefaultDuration が定義されている場合は最後のフレームのdurationも考慮する\n     * 単位 timecodeScale\n     *\n     * !!! if you need duration with seconds !!!\n     * ```js\n     * const nanosec = reader.duration * reader.timecodeScale;\n     * const sec = nanosec / 1000 / 1000 / 1000;\n     * ```\n     */\n    get: function () {\n      if (this.trackInfo.type === \"nothing\") {\n        console.warn(\"no video, no audio track\");\n        return 0;\n      }\n      // defaultDuration は 生の nano sec\n      var defaultDuration = 0;\n      // nanoseconds\n      var codecDelay = 0;\n      var lastTimecode = 0;\n      var _defaultDuration = this.trackDefaultDuration[this.trackInfo.trackNumber];\n      if (typeof _defaultDuration === \"number\") {\n        defaultDuration = _defaultDuration;\n      } else {\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=606000#c22\n        // default duration がないときに使う delta\n        if (this.trackInfo.type === \"both\") {\n          if (this.last2SimpleBlockAudioTrackTimecode[1] > this.last2SimpleBlockVideoTrackTimecode[1]) {\n            // audio diff\n            defaultDuration = (this.last2SimpleBlockAudioTrackTimecode[1] - this.last2SimpleBlockAudioTrackTimecode[0]) * this.timecodeScale;\n            // audio delay\n            var delay = this.trackCodecDelay[this.trackTypes.indexOf(2)]; // 2 => audio\n            if (typeof delay === \"number\") {\n              codecDelay = delay;\n            }\n            // audio timecode\n            lastTimecode = this.last2SimpleBlockAudioTrackTimecode[1];\n          } else {\n            // video diff\n            defaultDuration = (this.last2SimpleBlockVideoTrackTimecode[1] - this.last2SimpleBlockVideoTrackTimecode[0]) * this.timecodeScale;\n            // video delay\n            var delay = this.trackCodecDelay[this.trackTypes.indexOf(1)]; // 1 => video\n            if (typeof delay === \"number\") {\n              codecDelay = delay;\n            }\n            // video timecode\n            lastTimecode = this.last2SimpleBlockVideoTrackTimecode[1];\n          }\n        } else if (this.trackInfo.type === \"video\") {\n          defaultDuration = (this.last2SimpleBlockVideoTrackTimecode[1] - this.last2SimpleBlockVideoTrackTimecode[0]) * this.timecodeScale;\n          var delay = this.trackCodecDelay[this.trackInfo.trackNumber]; // 2 => audio\n          if (typeof delay === \"number\") {\n            codecDelay = delay;\n          }\n          lastTimecode = this.last2SimpleBlockVideoTrackTimecode[1];\n        } else if (this.trackInfo.type === \"audio\") {\n          defaultDuration = (this.last2SimpleBlockAudioTrackTimecode[1] - this.last2SimpleBlockAudioTrackTimecode[0]) * this.timecodeScale;\n          var delay = this.trackCodecDelay[this.trackInfo.trackNumber]; // 1 => video\n          if (typeof delay === \"number\") {\n            codecDelay = delay;\n          }\n          lastTimecode = this.last2SimpleBlockAudioTrackTimecode[1];\n        } // else { not reached }\n      }\n      // convert to timecodescale\n      var duration_nanosec = (this.lastClusterTimecode + lastTimecode) * this.timecodeScale + defaultDuration - codecDelay;\n      var duration = duration_nanosec / this.timecodeScale;\n      return Math.floor(duration);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  EBMLReader.prototype.addListener = function (event, listener) {\n    return _super.prototype.addListener.call(this, event, listener);\n  };\n  EBMLReader.prototype.put = function (elm) {\n    if (!this.hasLoggingStarted) {\n      this.hasLoggingStarted = true;\n      if (this.logging && this.logGroup) {\n        console.groupCollapsed(this.logGroup);\n      }\n    }\n    if (elm.type === \"m\") {\n      if (elm.isEnd) {\n        console.groupEnd();\n      } else {\n        console.group(elm.name + \":\" + elm.tagStart);\n      }\n    } else if (elm.type === \"b\") {\n      // for debug\n      //if(elm.name === \"SimpleBlock\"){\n      //const o = EBML.tools.ebmlBlock(elm.value);\n      //console.log(elm.name, elm.type, o.trackNumber, o.timecode);\n      //}else{\n      console.log(elm.name, elm.type);\n      //}\n    } else {\n      console.log(elm.name, elm.tagStart, elm.type, elm.value);\n    }\n  };\n  return EBMLReader;\n}(events_1.EventEmitter);\nexports.default = EBMLReader;\n;\n;\n;\n;","map":{"version":3,"names":["__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","defineProperty","exports","value","events_1","require","tools","EBMLReader","_super","_this","call","logGroup","hasLoggingStarted","metadataloaded","chunks","stack","segmentOffset","last2SimpleBlockVideoTrackTimecode","last2SimpleBlockAudioTrackTimecode","lastClusterTimecode","lastClusterPosition","timecodeScale","metadataSize","metadatas","cues","firstVideoBlockRead","firstAudioBlockRead","currentTrack","TrackNumber","TrackType","DefaultDuration","CodecDelay","trackTypes","trackDefaultDuration","trackCodecDelay","trackInfo","type","ended","logging","use_duration_every_simpleblock","use_webp","use_segment_info","drop_default_duration","stop","emit_segment_info","length","pop","console","groupEnd","data","videoTrackNum","indexOf","audioTrackNum","trackNumber","emit","timecode","duration","read","elm","drop","isEnd","parent_1","level","dataEnd","dataSize","dataStart","unknownSize","o","assign","name","push","warn","_a","ebmlBlock","frames_1","frames","CueTime","CueTrack","CueClusterPosition","forEach","frame","startcode","slice","toString","webpBuf","VP8BitStreamToRiffWebPBuffer","webp","Blob","currentTime","tagStart","put","get","defaultDuration","codecDelay","lastTimecode","_defaultDuration","delay","duration_nanosec","Math","floor","enumerable","configurable","addListener","event","listener","groupCollapsed","group","log","EventEmitter","default"],"sources":["/Users/ruchireddy/trick-tracker/frontend/node_modules/ts-ebml/lib/EBMLReader.js"],"sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar events_1 = require(\"events\");\nvar tools = require(\"./tools\");\n/**\n * This is an informal code for reference.\n * EBMLReader is a class for getting information to enable seeking Webm recorded by MediaRecorder.\n * So please do not use for regular WebM files.\n */\nvar EBMLReader = (function (_super) {\n    __extends(EBMLReader, _super);\n    function EBMLReader() {\n        var _this = _super.call(this) || this;\n        _this.logGroup = \"\";\n        _this.hasLoggingStarted = false;\n        _this.metadataloaded = false;\n        _this.chunks = [];\n        _this.stack = [];\n        _this.segmentOffset = 0;\n        _this.last2SimpleBlockVideoTrackTimecode = [0, 0];\n        _this.last2SimpleBlockAudioTrackTimecode = [0, 0];\n        _this.lastClusterTimecode = 0;\n        _this.lastClusterPosition = 0;\n        _this.timecodeScale = 1000000; // webm default TimecodeScale is 1ms\n        _this.metadataSize = 0;\n        _this.metadatas = [];\n        _this.cues = [];\n        _this.firstVideoBlockRead = false;\n        _this.firstAudioBlockRead = false;\n        _this.currentTrack = { TrackNumber: -1, TrackType: -1, DefaultDuration: null, CodecDelay: null };\n        _this.trackTypes = [];\n        _this.trackDefaultDuration = [];\n        _this.trackCodecDelay = [];\n        _this.trackInfo = { type: \"nothing\" };\n        _this.ended = false;\n        _this.logging = false;\n        _this.use_duration_every_simpleblock = false;\n        _this.use_webp = false;\n        _this.use_segment_info = true;\n        _this.drop_default_duration = true;\n        return _this;\n    }\n    /**\n     * emit final state.\n     */\n    EBMLReader.prototype.stop = function () {\n        this.ended = true;\n        this.emit_segment_info();\n        // clean up any unclosed Master Elements at the end of the stream.\n        while (this.stack.length) {\n            this.stack.pop();\n            if (this.logging) {\n                console.groupEnd();\n            }\n        }\n        // close main group if set, logging is enabled, and has actually logged anything.\n        if (this.logging && this.hasLoggingStarted && this.logGroup) {\n            console.groupEnd();\n        }\n    };\n    /**\n     * emit chunk info\n     */\n    EBMLReader.prototype.emit_segment_info = function () {\n        var data = this.chunks;\n        this.chunks = [];\n        if (!this.metadataloaded) {\n            this.metadataloaded = true;\n            this.metadatas = data;\n            var videoTrackNum = this.trackTypes.indexOf(1); // find first video track\n            var audioTrackNum = this.trackTypes.indexOf(2); // find first audio track\n            this.trackInfo = videoTrackNum >= 0 && audioTrackNum >= 0 ? { type: \"both\", trackNumber: videoTrackNum }\n                : videoTrackNum >= 0 ? { type: \"video\", trackNumber: videoTrackNum }\n                    : audioTrackNum >= 0 ? { type: \"audio\", trackNumber: audioTrackNum }\n                        : { type: \"nothing\" };\n            if (!this.use_segment_info) {\n                return;\n            }\n            this.emit(\"metadata\", { data: data, metadataSize: this.metadataSize });\n        }\n        else {\n            if (!this.use_segment_info) {\n                return;\n            }\n            var timecode = this.lastClusterTimecode;\n            var duration = this.duration;\n            var timecodeScale = this.timecodeScale;\n            this.emit(\"cluster\", { timecode: timecode, data: data });\n            this.emit(\"duration\", { timecodeScale: timecodeScale, duration: duration });\n        }\n    };\n    EBMLReader.prototype.read = function (elm) {\n        var _this = this;\n        var drop = false;\n        if (this.ended) {\n            // reader is finished\n            return;\n        }\n        if (elm.type === \"m\") {\n            // 閉じタグの自動挿入\n            if (elm.isEnd) {\n                this.stack.pop();\n            }\n            else {\n                var parent_1 = this.stack[this.stack.length - 1];\n                if (parent_1 != null && parent_1.level >= elm.level) {\n                    // 閉じタグなしでレベルが下がったら閉じタグを挿入\n                    this.stack.pop();\n                    // From http://w3c.github.io/media-source/webm-byte-stream-format.html#webm-media-segments\n                    // This fixes logging for webm streams with Cluster of unknown length and no Cluster closing elements.\n                    if (this.logging) {\n                        console.groupEnd();\n                    }\n                    parent_1.dataEnd = elm.dataEnd;\n                    parent_1.dataSize = elm.dataEnd - parent_1.dataStart;\n                    parent_1.unknownSize = false;\n                    var o = Object.assign({}, parent_1, { name: parent_1.name, type: parent_1.type, isEnd: true });\n                    this.chunks.push(o);\n                }\n                this.stack.push(elm);\n            }\n        }\n        if (elm.type === \"m\" && elm.name == \"Segment\") {\n            if (this.segmentOffset != 0) {\n                console.warn(\"Multiple segments detected!\");\n            }\n            this.segmentOffset = elm.dataStart;\n            this.emit(\"segment_offset\", this.segmentOffset);\n        }\n        else if (elm.type === \"b\" && elm.name === \"SimpleBlock\") {\n            var _a = tools.ebmlBlock(elm.data), timecode = _a.timecode, trackNumber = _a.trackNumber, frames_1 = _a.frames;\n            if (this.trackTypes[trackNumber] === 1) {\n                if (!this.firstVideoBlockRead) {\n                    this.firstVideoBlockRead = true;\n                    if (this.trackInfo.type === \"both\" || this.trackInfo.type === \"video\") {\n                        var CueTime = this.lastClusterTimecode + timecode;\n                        this.cues.push({ CueTrack: trackNumber, CueClusterPosition: this.lastClusterPosition, CueTime: CueTime });\n                        this.emit(\"cue_info\", { CueTrack: trackNumber, CueClusterPosition: this.lastClusterPosition, CueTime: this.lastClusterTimecode });\n                        this.emit(\"cue\", { CueTrack: trackNumber, CueClusterPosition: this.lastClusterPosition, CueTime: CueTime });\n                    }\n                }\n                this.last2SimpleBlockVideoTrackTimecode = [this.last2SimpleBlockVideoTrackTimecode[1], timecode];\n            }\n            else if (this.trackTypes[trackNumber] === 2) {\n                if (!this.firstAudioBlockRead) {\n                    this.firstAudioBlockRead = true;\n                    if (this.trackInfo.type === \"audio\") {\n                        var CueTime = this.lastClusterTimecode + timecode;\n                        this.cues.push({ CueTrack: trackNumber, CueClusterPosition: this.lastClusterPosition, CueTime: CueTime });\n                        this.emit(\"cue_info\", { CueTrack: trackNumber, CueClusterPosition: this.lastClusterPosition, CueTime: this.lastClusterTimecode });\n                        this.emit(\"cue\", { CueTrack: trackNumber, CueClusterPosition: this.lastClusterPosition, CueTime: CueTime });\n                    }\n                }\n                this.last2SimpleBlockAudioTrackTimecode = [this.last2SimpleBlockAudioTrackTimecode[1], timecode];\n            }\n            if (this.use_duration_every_simpleblock) {\n                this.emit(\"duration\", { timecodeScale: this.timecodeScale, duration: this.duration });\n            }\n            if (this.use_webp) {\n                frames_1.forEach(function (frame) {\n                    var startcode = frame.slice(3, 6).toString(\"hex\");\n                    if (startcode !== \"9d012a\") {\n                        return;\n                    }\n                    ; // VP8 の場合\n                    var webpBuf = tools.VP8BitStreamToRiffWebPBuffer(frame);\n                    var webp = new Blob([webpBuf], { type: \"image/webp\" });\n                    var currentTime = _this.duration;\n                    _this.emit(\"webp\", { currentTime: currentTime, webp: webp });\n                });\n            }\n        }\n        else if (elm.type === \"m\" && elm.name === \"Cluster\" && elm.isEnd === false) {\n            this.firstVideoBlockRead = false;\n            this.firstAudioBlockRead = false;\n            this.emit_segment_info();\n            this.emit(\"cluster_ptr\", elm.tagStart);\n            this.lastClusterPosition = elm.tagStart;\n        }\n        else if (elm.type === \"u\" && elm.name === \"Timecode\") {\n            this.lastClusterTimecode = elm.value;\n        }\n        else if (elm.type === \"u\" && elm.name === \"TimecodeScale\") {\n            this.timecodeScale = elm.value;\n        }\n        else if (elm.type === \"m\" && elm.name === \"TrackEntry\") {\n            if (elm.isEnd) {\n                this.trackTypes[this.currentTrack.TrackNumber] = this.currentTrack.TrackType;\n                this.trackDefaultDuration[this.currentTrack.TrackNumber] = this.currentTrack.DefaultDuration;\n                this.trackCodecDelay[this.currentTrack.TrackNumber] = this.currentTrack.CodecDelay;\n            }\n            else {\n                this.currentTrack = { TrackNumber: -1, TrackType: -1, DefaultDuration: null, CodecDelay: null };\n            }\n        }\n        else if (elm.type === \"u\" && elm.name === \"TrackType\") {\n            this.currentTrack.TrackType = elm.value;\n        }\n        else if (elm.type === \"u\" && elm.name === \"TrackNumber\") {\n            this.currentTrack.TrackNumber = elm.value;\n        }\n        else if (elm.type === \"u\" && elm.name === \"CodecDelay\") {\n            this.currentTrack.CodecDelay = elm.value;\n        }\n        else if (elm.type === \"u\" && elm.name === \"DefaultDuration\") {\n            // media source api は DefaultDuration を計算するとバグる。\n            // https://bugs.chromium.org/p/chromium/issues/detail?id=606000#c22\n            // chrome 58 ではこれを回避するために DefaultDuration 要素を抜き取った。\n            // chrome 58 以前でもこのタグを抜き取ることで回避できる\n            if (this.drop_default_duration) {\n                console.warn(\"DefaultDuration detected!, remove it\");\n                drop = true;\n            }\n            else {\n                this.currentTrack.DefaultDuration = elm.value;\n            }\n        }\n        else if (elm.name === \"unknown\") {\n            console.warn(elm);\n        }\n        if (!this.metadataloaded && elm.dataEnd > 0) {\n            this.metadataSize = elm.dataEnd;\n        }\n        if (!drop) {\n            this.chunks.push(elm);\n        }\n        if (this.logging) {\n            this.put(elm);\n        }\n    };\n    Object.defineProperty(EBMLReader.prototype, \"duration\", {\n        /**\n         * DefaultDuration が定義されている場合は最後のフレームのdurationも考慮する\n         * 単位 timecodeScale\n         *\n         * !!! if you need duration with seconds !!!\n         * ```js\n         * const nanosec = reader.duration * reader.timecodeScale;\n         * const sec = nanosec / 1000 / 1000 / 1000;\n         * ```\n         */\n        get: function () {\n            if (this.trackInfo.type === \"nothing\") {\n                console.warn(\"no video, no audio track\");\n                return 0;\n            }\n            // defaultDuration は 生の nano sec\n            var defaultDuration = 0;\n            // nanoseconds\n            var codecDelay = 0;\n            var lastTimecode = 0;\n            var _defaultDuration = this.trackDefaultDuration[this.trackInfo.trackNumber];\n            if (typeof _defaultDuration === \"number\") {\n                defaultDuration = _defaultDuration;\n            }\n            else {\n                // https://bugs.chromium.org/p/chromium/issues/detail?id=606000#c22\n                // default duration がないときに使う delta\n                if (this.trackInfo.type === \"both\") {\n                    if (this.last2SimpleBlockAudioTrackTimecode[1] > this.last2SimpleBlockVideoTrackTimecode[1]) {\n                        // audio diff\n                        defaultDuration = (this.last2SimpleBlockAudioTrackTimecode[1] - this.last2SimpleBlockAudioTrackTimecode[0]) * this.timecodeScale;\n                        // audio delay\n                        var delay = this.trackCodecDelay[this.trackTypes.indexOf(2)]; // 2 => audio\n                        if (typeof delay === \"number\") {\n                            codecDelay = delay;\n                        }\n                        // audio timecode\n                        lastTimecode = this.last2SimpleBlockAudioTrackTimecode[1];\n                    }\n                    else {\n                        // video diff\n                        defaultDuration = (this.last2SimpleBlockVideoTrackTimecode[1] - this.last2SimpleBlockVideoTrackTimecode[0]) * this.timecodeScale;\n                        // video delay\n                        var delay = this.trackCodecDelay[this.trackTypes.indexOf(1)]; // 1 => video\n                        if (typeof delay === \"number\") {\n                            codecDelay = delay;\n                        }\n                        // video timecode\n                        lastTimecode = this.last2SimpleBlockVideoTrackTimecode[1];\n                    }\n                }\n                else if (this.trackInfo.type === \"video\") {\n                    defaultDuration = (this.last2SimpleBlockVideoTrackTimecode[1] - this.last2SimpleBlockVideoTrackTimecode[0]) * this.timecodeScale;\n                    var delay = this.trackCodecDelay[this.trackInfo.trackNumber]; // 2 => audio\n                    if (typeof delay === \"number\") {\n                        codecDelay = delay;\n                    }\n                    lastTimecode = this.last2SimpleBlockVideoTrackTimecode[1];\n                }\n                else if (this.trackInfo.type === \"audio\") {\n                    defaultDuration = (this.last2SimpleBlockAudioTrackTimecode[1] - this.last2SimpleBlockAudioTrackTimecode[0]) * this.timecodeScale;\n                    var delay = this.trackCodecDelay[this.trackInfo.trackNumber]; // 1 => video\n                    if (typeof delay === \"number\") {\n                        codecDelay = delay;\n                    }\n                    lastTimecode = this.last2SimpleBlockAudioTrackTimecode[1];\n                } // else { not reached }\n            }\n            // convert to timecodescale\n            var duration_nanosec = ((this.lastClusterTimecode + lastTimecode) * this.timecodeScale) + defaultDuration - codecDelay;\n            var duration = duration_nanosec / this.timecodeScale;\n            return Math.floor(duration);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    EBMLReader.prototype.addListener = function (event, listener) {\n        return _super.prototype.addListener.call(this, event, listener);\n    };\n    EBMLReader.prototype.put = function (elm) {\n        if (!this.hasLoggingStarted) {\n            this.hasLoggingStarted = true;\n            if (this.logging && this.logGroup) {\n                console.groupCollapsed(this.logGroup);\n            }\n        }\n        if (elm.type === \"m\") {\n            if (elm.isEnd) {\n                console.groupEnd();\n            }\n            else {\n                console.group(elm.name + \":\" + elm.tagStart);\n            }\n        }\n        else if (elm.type === \"b\") {\n            // for debug\n            //if(elm.name === \"SimpleBlock\"){\n            //const o = EBML.tools.ebmlBlock(elm.value);\n            //console.log(elm.name, elm.type, o.trackNumber, o.timecode);\n            //}else{\n            console.log(elm.name, elm.type);\n            //}\n        }\n        else {\n            console.log(elm.name, elm.tagStart, elm.type, elm.value);\n        }\n    };\n    return EBMLReader;\n}(events_1.EventEmitter));\nexports.default = EBMLReader;\n;\n;\n;\n;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}