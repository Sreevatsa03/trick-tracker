{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/// <reference types=\"node\"/>\nvar int64_buffer_1 = require(\"int64-buffer\");\nvar EBMLEncoder_1 = require(\"./EBMLEncoder\");\nvar _Buffer = require(\"buffer/\");\nvar _tools = require(\"ebml/lib/ebml/tools\");\nvar _block = require(\"ebml-block\");\nexports.Buffer = _Buffer.Buffer;\nexports.readVint = _tools.readVint;\nexports.writeVint = _tools.writeVint;\nexports.ebmlBlock = _block;\nfunction readBlock(buf) {\n  return exports.ebmlBlock(new exports.Buffer(buf));\n}\nexports.readBlock = readBlock;\n/**\n  * @param end - if end === false then length is unknown\n  */\nfunction encodeTag(tagId, tagData, unknownSize) {\n  if (unknownSize === void 0) {\n    unknownSize = false;\n  }\n  return concat([tagId, unknownSize ? new exports.Buffer('01ffffffffffffff', 'hex') : exports.writeVint(tagData.length), tagData]);\n}\nexports.encodeTag = encodeTag;\n/**\n * @return - SimpleBlock to WebP Filter\n */\nfunction WebPFrameFilter(elms) {\n  return WebPBlockFilter(elms).reduce(function (lst, elm) {\n    var o = exports.ebmlBlock(elm.data);\n    return o.frames.reduce(function (lst, frame) {\n      // https://developers.Blob.com/speed/webp/docs/riff_container\n      var webpBuf = VP8BitStreamToRiffWebPBuffer(frame);\n      var webp = new Blob([webpBuf], {\n        type: \"image/webp\"\n      });\n      return lst.concat(webp);\n    }, lst);\n  }, []);\n}\nexports.WebPFrameFilter = WebPFrameFilter;\n/**\n * WebP ファイルにできる SimpleBlock の パスフィルタ\n */\nfunction WebPBlockFilter(elms) {\n  return elms.reduce(function (lst, elm) {\n    if (elm.type !== \"b\") {\n      return lst;\n    }\n    if (elm.name !== \"SimpleBlock\") {\n      return lst;\n    }\n    var o = exports.ebmlBlock(elm.data);\n    var hasWebP = o.frames.some(function (frame) {\n      // https://tools.ietf.org/html/rfc6386#section-19.1\n      var startcode = frame.slice(3, 6).toString(\"hex\");\n      return startcode === \"9d012a\";\n    });\n    if (!hasWebP) {\n      return lst;\n    }\n    return lst.concat(elm);\n  }, []);\n}\nexports.WebPBlockFilter = WebPBlockFilter;\n/**\n * @param frame - VP8 BitStream のうち startcode をもつ frame\n * @return - WebP ファイルの ArrayBuffer\n */\nfunction VP8BitStreamToRiffWebPBuffer(frame) {\n  var VP8Chunk = createRIFFChunk(\"VP8 \", frame);\n  var WebPChunk = concat([new exports.Buffer(\"WEBP\", \"ascii\"), VP8Chunk]);\n  return createRIFFChunk(\"RIFF\", WebPChunk);\n}\nexports.VP8BitStreamToRiffWebPBuffer = VP8BitStreamToRiffWebPBuffer;\n/**\n * RIFF データチャンクを作る\n */\nfunction createRIFFChunk(FourCC, chunk) {\n  var chunkSize = new exports.Buffer(4);\n  chunkSize.writeUInt32LE(chunk.byteLength, 0);\n  return concat([new exports.Buffer(FourCC.substr(0, 4), \"ascii\"), chunkSize, chunk, new exports.Buffer(chunk.byteLength % 2 === 0 ? 0 : 1) // padding\n  ]);\n}\n\nexports.createRIFFChunk = createRIFFChunk;\n/* Original Metadata\n\n m  0\tEBML\n u  1\t  EBMLVersion 1\n u  1\t  EBMLReadVersion 1\n u  1\t  EBMLMaxIDLength 4\n u  1\t  EBMLMaxSizeLength 8\n s  1\t  DocType webm\n u  1\t  DocTypeVersion 4\n u  1\t  DocTypeReadVersion 2\n m  0\tSegment\n m  1\t  Info                                segmentContentStartPos, all CueClusterPositions provided in info.cues will be relative to here and will need adjusted\n u  2\t    TimecodeScale 1000000\n 8  2\t    MuxingApp Chrome\n 8  2\t    WritingApp Chrome\n m  1\t  Tracks                              tracksStartPos\n m  2\t    TrackEntry\n u  3\t      TrackNumber 1\n u  3\t      TrackUID 31790271978391090\n u  3\t      TrackType 2\n s  3\t      CodecID A_OPUS\n b  3\t      CodecPrivate <Buffer 19>\n m  3\t      Audio\n f  4\t        SamplingFrequency 48000\n u  4\t        Channels 1\n m  2\t    TrackEntry\n u  3\t      TrackNumber 2\n u  3\t      TrackUID 24051277436254136\n u  3\t      TrackType 1\n s  3\t      CodecID V_VP8\n m  3\t      Video\n u  4\t        PixelWidth 1024\n u  4\t        PixelHeight 576\n m  1\t  Cluster                             clusterStartPos\n u  2\t    Timecode 0\n b  2\t    SimpleBlock track:2 timecode:0\tkeyframe:true\tinvisible:false\tdiscardable:false\tlacing:1\n*/\n/* Desired Metadata\n\n m\t0 EBML\n u\t1   EBMLVersion 1\n u\t1   EBMLReadVersion 1\n u\t1   EBMLMaxIDLength 4\n u\t1   EBMLMaxSizeLength 8\n s\t1   DocType webm\n u\t1   DocTypeVersion 4\n u\t1   DocTypeReadVersion 2\n m\t0 Segment\n m\t1   SeekHead                            -> This is SeekPosition 0, so all SeekPositions can be calculated as (bytePos - segmentContentStartPos), which is 44 in this case\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x15, 0x49, 0xA9, 0x66])  Info\n u\t3       SeekPosition                    -> infoStartPos =\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x16, 0x54, 0xAE, 0x6B])  Tracks\n u\t3       SeekPosition { tracksStartPos }\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x1C, 0x53, 0xBB, 0x6B])  Cues\n u\t3       SeekPosition { cuesStartPos }\n m\t1   Info\n f\t2     Duration 32480                    -> overwrite, or insert if it doesn't exist\n u\t2     TimecodeScale 1000000\n 8\t2     MuxingApp Chrome\n 8\t2     WritingApp Chrome\n m\t1   Tracks\n m\t2     TrackEntry\n u\t3       TrackNumber 1\n u\t3       TrackUID 31790271978391090\n u\t3       TrackType 2\n s\t3       CodecID A_OPUS\n b\t3       CodecPrivate <Buffer 19>\n m\t3       Audio\n f\t4         SamplingFrequency 48000\n u\t4         Channels 1\n m\t2     TrackEntry\n u\t3       TrackNumber 2\n u\t3       TrackUID 24051277436254136\n u\t3       TrackType 1\n s\t3       CodecID V_VP8\n m\t3       Video\n u\t4         PixelWidth 1024\n u\t4         PixelHeight 576\n m  1   Cues                                -> cuesStartPos\n m  2     CuePoint\n u  3       CueTime 0\n m  3       CueTrackPositions\n u  4         CueTrack 1\n u  4         CueClusterPosition 3911\n m  2     CuePoint\n u  3       CueTime 600\n m  3       CueTrackPositions\n u  4         CueTrack 1\n u  4         CueClusterPosition 3911\n m  1   Cluster\n u  2     Timecode 0\n b  2     SimpleBlock track:2 timecode:0\tkeyframe:true\tinvisible:false\tdiscardable:false\tlacing:1\n*/\n/**\n * convert the metadata from a streaming webm bytestream to a seekable file by inserting Duration, Seekhead and Cues\n * @param originalMetadata - orginal metadata (everything before the clusters start) from media recorder\n * @param duration - Duration (TimecodeScale)\n * @param cues - cue points for clusters\n */\nfunction makeMetadataSeekable(originalMetadata, duration, cuesInfo) {\n  // extract the header, we can reuse this as-is\n  var header = extractElement(\"EBML\", originalMetadata);\n  var headerSize = encodedSizeOfEbml(header);\n  //console.error(\"Header size: \" + headerSize);\n  //printElementIds(header);\n  // After the header comes the Segment open tag, which in this implementation is always 12 bytes (4 byte id, 8 byte 'unknown length')\n  // After that the segment content starts. All SeekPositions and CueClusterPosition must be relative to segmentContentStartPos\n  var segmentContentStartPos = headerSize + 12;\n  //console.error(\"segmentContentStartPos: \" + segmentContentStartPos);    \n  // find the original metadata size, and adjust it for header size and Segment start element so we can keep all positions relative to segmentContentStartPos\n  var originalMetadataSize = originalMetadata[originalMetadata.length - 1].dataEnd - segmentContentStartPos;\n  //console.error(\"Original Metadata size: \" + originalMetadataSize);\n  //printElementIds(originalMetadata);\n  // extract the segment info, remove the potentially existing Duration element, and add our own one.\n  var info = extractElement(\"Info\", originalMetadata);\n  removeElement(\"Duration\", info);\n  info.splice(1, 0, {\n    name: \"Duration\",\n    type: \"f\",\n    data: createFloatBuffer(duration, 8)\n  });\n  var infoSize = encodedSizeOfEbml(info);\n  //console.error(\"Info size: \" + infoSize);\n  //printElementIds(info);  \n  // extract the track info, we can re-use this as is\n  var tracks = extractElement(\"Tracks\", originalMetadata);\n  var tracksSize = encodedSizeOfEbml(tracks);\n  //console.error(\"Tracks size: \" + tracksSize);\n  //printElementIds(tracks);  \n  var seekHeadSize = 47; // Initial best guess, but could be slightly larger if the Cues element is huge.\n  var seekHead = [];\n  var cuesSize = 5 + cuesInfo.length * 15; // very rough initial approximation, depends a lot on file size and number of CuePoints                   \n  var cues = [];\n  var lastSizeDifference = -1; // \n  // The size of SeekHead and Cues elements depends on how many bytes the offsets values can be encoded in.\n  // The actual offsets in CueClusterPosition depend on the final size of the SeekHead and Cues elements\n  // We need to iteratively converge to a stable solution.\n  var maxIterations = 10;\n  var _loop_1 = function (i) {\n    // SeekHead starts at 0\n    var infoStart = seekHeadSize; // Info comes directly after SeekHead\n    var tracksStart = infoStart + infoSize; // Tracks comes directly after Info\n    var cuesStart = tracksStart + tracksSize; // Cues starts directly after \n    var newMetadataSize = cuesStart + cuesSize; // total size of metadata  \n    // This is the offset all CueClusterPositions should be adjusted by due to the metadata size changing.\n    var sizeDifference = newMetadataSize - originalMetadataSize;\n    // console.error(`infoStart: ${infoStart}, infoSize: ${infoSize}`);\n    // console.error(`tracksStart: ${tracksStart}, tracksSize: ${tracksSize}`);\n    // console.error(`cuesStart: ${cuesStart}, cuesSize: ${cuesSize}`);\n    // console.error(`originalMetadataSize: ${originalMetadataSize}, newMetadataSize: ${newMetadataSize}, sizeDifference: ${sizeDifference}`); \n    // create the SeekHead element\n    seekHead = [];\n    seekHead.push({\n      name: \"SeekHead\",\n      type: \"m\",\n      isEnd: false\n    });\n    seekHead.push({\n      name: \"Seek\",\n      type: \"m\",\n      isEnd: false\n    });\n    seekHead.push({\n      name: \"SeekID\",\n      type: \"b\",\n      data: new exports.Buffer([0x15, 0x49, 0xA9, 0x66])\n    }); // Info\n    seekHead.push({\n      name: \"SeekPosition\",\n      type: \"u\",\n      data: createUIntBuffer(infoStart)\n    });\n    seekHead.push({\n      name: \"Seek\",\n      type: \"m\",\n      isEnd: true\n    });\n    seekHead.push({\n      name: \"Seek\",\n      type: \"m\",\n      isEnd: false\n    });\n    seekHead.push({\n      name: \"SeekID\",\n      type: \"b\",\n      data: new exports.Buffer([0x16, 0x54, 0xAE, 0x6B])\n    }); // Tracks\n    seekHead.push({\n      name: \"SeekPosition\",\n      type: \"u\",\n      data: createUIntBuffer(tracksStart)\n    });\n    seekHead.push({\n      name: \"Seek\",\n      type: \"m\",\n      isEnd: true\n    });\n    seekHead.push({\n      name: \"Seek\",\n      type: \"m\",\n      isEnd: false\n    });\n    seekHead.push({\n      name: \"SeekID\",\n      type: \"b\",\n      data: new exports.Buffer([0x1C, 0x53, 0xBB, 0x6B])\n    }); // Cues\n    seekHead.push({\n      name: \"SeekPosition\",\n      type: \"u\",\n      data: createUIntBuffer(cuesStart)\n    });\n    seekHead.push({\n      name: \"Seek\",\n      type: \"m\",\n      isEnd: true\n    });\n    seekHead.push({\n      name: \"SeekHead\",\n      type: \"m\",\n      isEnd: true\n    });\n    seekHeadSize = encodedSizeOfEbml(seekHead);\n    //console.error(\"SeekHead size: \" + seekHeadSize);\n    //printElementIds(seekHead);  \n    // create the Cues element\n    cues = [];\n    cues.push({\n      name: \"Cues\",\n      type: \"m\",\n      isEnd: false\n    });\n    cuesInfo.forEach(function (_a) {\n      var CueTrack = _a.CueTrack,\n        CueClusterPosition = _a.CueClusterPosition,\n        CueTime = _a.CueTime;\n      cues.push({\n        name: \"CuePoint\",\n        type: \"m\",\n        isEnd: false\n      });\n      cues.push({\n        name: \"CueTime\",\n        type: \"u\",\n        data: createUIntBuffer(CueTime)\n      });\n      cues.push({\n        name: \"CueTrackPositions\",\n        type: \"m\",\n        isEnd: false\n      });\n      cues.push({\n        name: \"CueTrack\",\n        type: \"u\",\n        data: createUIntBuffer(CueTrack)\n      });\n      //console.error(`CueClusterPosition: ${CueClusterPosition}, Corrected to: ${CueClusterPosition - segmentContentStartPos}  , offset by ${sizeDifference} to become ${(CueClusterPosition - segmentContentStartPos) + sizeDifference - segmentContentStartPos}`);\n      // EBMLReader returns CueClusterPosition with absolute byte offsets. The Cues section expects them as offsets from the first level 1 element of the Segment, so we need to adjust it.\n      CueClusterPosition -= segmentContentStartPos;\n      // We also need to adjust to take into account the change in metadata size from when EBMLReader read the original metadata.\n      CueClusterPosition += sizeDifference;\n      cues.push({\n        name: \"CueClusterPosition\",\n        type: \"u\",\n        data: createUIntBuffer(CueClusterPosition)\n      });\n      cues.push({\n        name: \"CueTrackPositions\",\n        type: \"m\",\n        isEnd: true\n      });\n      cues.push({\n        name: \"CuePoint\",\n        type: \"m\",\n        isEnd: true\n      });\n    });\n    cues.push({\n      name: \"Cues\",\n      type: \"m\",\n      isEnd: true\n    });\n    cuesSize = encodedSizeOfEbml(cues);\n    //console.error(\"Cues size: \" + cuesSize);   \n    //console.error(\"Cue count: \" + cuesInfo.length);\n    //printElementIds(cues);      \n    // If the new MetadataSize is not the same as the previous iteration, we need to run once more.\n    if (lastSizeDifference !== sizeDifference) {\n      lastSizeDifference = sizeDifference;\n      if (i === maxIterations - 1) {\n        throw new Error(\"Failed to converge to a stable metadata size\");\n      }\n    } else {\n      return \"break\";\n    }\n  };\n  for (var i = 0; i < maxIterations; i++) {\n    var state_1 = _loop_1(i);\n    if (state_1 === \"break\") break;\n  }\n  var finalMetadata = [].concat.apply([], [header, {\n    name: \"Segment\",\n    type: \"m\",\n    isEnd: false,\n    unknownSize: true\n  }, seekHead, info, tracks, cues]);\n  var result = new EBMLEncoder_1.default().encode(finalMetadata);\n  //printElementIds(finalMetadata);\n  //console.error(`Final metadata buffer size: ${result.byteLength}`);\n  //console.error(`Final metadata buffer size without header and segment: ${result.byteLength-segmentContentStartPos}`);\n  return result;\n}\nexports.makeMetadataSeekable = makeMetadataSeekable;\n/**\n * print all element id names in a list\n\n * @param metadata - array of EBML elements to print\n *\nexport function printElementIds(metadata: EBML.EBMLElementBuffer[]) {\n\n  let result: EBML.EBMLElementBuffer[] = [];\n  let start: number = -1;\n\n  for (let i = 0; i < metadata.length; i++) {\n    console.error(\"\\t id: \" + metadata[i].name);\n  }\n}\n*/\n/**\n * remove all occurances of an EBML element from an array of elements\n * If it's a MasterElement you will also remove the content. (everything between start and end)\n * @param idName - name of the EBML Element to remove.\n * @param metadata - array of EBML elements to search\n */\nfunction removeElement(idName, metadata) {\n  var result = [];\n  var start = -1;\n  for (var i = 0; i < metadata.length; i++) {\n    var element = metadata[i];\n    if (element.name === idName) {\n      // if it's a Master element, extract the start and end element, and everything in between\n      if (element.type === \"m\") {\n        if (!element.isEnd) {\n          start = i;\n        } else {\n          // we've reached the end, extract the whole thing\n          if (start == -1) throw new Error(\"Detected \" + idName + \" closing element before finding the start\");\n          metadata.splice(start, i - start + 1);\n          return;\n        }\n      } else {\n        // not a Master element, so we've found what we're looking for.\n        metadata.splice(i, 1);\n        return;\n      }\n    }\n  }\n}\nexports.removeElement = removeElement;\n/**\n * extract the first occurance of an EBML tag from a flattened array of EBML data.\n * If it's a MasterElement you will also get the content. (everything between start and end)\n * @param idName - name of the EBML Element to extract.\n * @param metadata - array of EBML elements to search\n */\nfunction extractElement(idName, metadata) {\n  var result = [];\n  var start = -1;\n  for (var i = 0; i < metadata.length; i++) {\n    var element = metadata[i];\n    if (element.name === idName) {\n      // if it's a Master element, extract the start and end element, and everything in between\n      if (element.type === \"m\") {\n        if (!element.isEnd) {\n          start = i;\n        } else {\n          // we've reached the end, extract the whole thing\n          if (start == -1) throw new Error(\"Detected \" + idName + \" closing element before finding the start\");\n          result = metadata.slice(start, i + 1);\n          break;\n        }\n      } else {\n        // not a Master element, so we've found what we're looking for.\n        result.push(metadata[i]);\n        break;\n      }\n    }\n  }\n  return result;\n}\nexports.extractElement = extractElement;\n/**\n * @deprecated\n * metadata に対して duration と seekhead を追加した metadata を返す\n * @param metadata - 変更前の webm における ファイル先頭から 最初の Cluster 要素までの 要素\n * @param duration - Duration (TimecodeScale)\n * @param cues - cue points for clusters\n * @deprecated @param clusterPtrs - 変更前の webm における SeekHead に追加する Cluster 要素 への start pointer\n * @deprecated @param cueInfos - please use cues.\n */\nfunction putRefinedMetaData(metadata, info) {\n  if (Array.isArray(info.cueInfos) && !Array.isArray(info.cues)) {\n    console.warn(\"putRefinedMetaData: info.cueInfos property is deprecated. please use info.cues\");\n    info.cues = info.cueInfos;\n  }\n  var ebml = [];\n  var payload = [];\n  for (var i_1 = 0; i_1 < metadata.length; i_1++) {\n    var elm = metadata[i_1];\n    if (elm.type === \"m\" && elm.name === \"Segment\") {\n      ebml = metadata.slice(0, i_1);\n      payload = metadata.slice(i_1);\n      if (elm.unknownSize) {\n        payload.shift(); // remove segment tag\n        break;\n      }\n      throw new Error(\"this metadata is not streaming webm file\");\n    }\n  }\n  // *0    *4    *5  *36      *40   *48=segmentOffset              *185=originalPayloadOffsetEnd\n  // |     |     |   |        |     |                              |\n  // [EBML][size]....[Segment][size][Info][size][Duration][size]...[Cluster]\n  // |               |        |^inf |                              |\n  // |               +segmentSiz(12)+                              |\n  // +-ebmlSize(36)--+        |     +-payloadSize(137)-------------+offsetEndDiff+\n  //                 |        |     +-newPayloadSize(??)-------------------------+\n  //                 |        |     |                                            |\n  //                 [Segment][size][Info][size][Duration][size]....[size][value][Cluster]\n  //                           ^                                                 |\n  //                           |                                                 *??=newPayloadOffsetEnd\n  //                           inf\n  if (!(payload[payload.length - 1].dataEnd > 0)) {\n    throw new Error(\"metadata dataEnd has wrong number\");\n  }\n  var originalPayloadOffsetEnd = payload[payload.length - 1].dataEnd; // = first cluster ptr\n  var ebmlSize = ebml[ebml.length - 1].dataEnd; // = first segment ptr\n  var refinedEBMLSize = new EBMLEncoder_1.default().encode(ebml).byteLength;\n  var offsetDiff = refinedEBMLSize - ebmlSize;\n  var payloadSize = originalPayloadOffsetEnd - payload[0].tagStart;\n  var segmentSize = payload[0].tagStart - ebmlSize;\n  var segmentOffset = payload[0].tagStart;\n  var segmentTagBuf = new exports.Buffer([0x18, 0x53, 0x80, 0x67]); // Segment\n  var segmentSizeBuf = new exports.Buffer('01ffffffffffffff', 'hex'); // Segmentの最後の位置は無数の Cluster 依存なので。 writeVint(newPayloadSize).byteLength ではなく、 infinity.\n  var _segmentSize = segmentTagBuf.byteLength + segmentSizeBuf.byteLength; // == segmentSize\n  var newPayloadSize = payloadSize;\n  // We need the size to be stable between two refinements in order for our offsets to be correct\n  // Bound the number of possible refinements so we can't go infinate if something goes wrong\n  var i;\n  for (i = 1; i < 20; i++) {\n    var newPayloadOffsetEnd = ebmlSize + _segmentSize + newPayloadSize;\n    var offsetEndDiff = newPayloadOffsetEnd - originalPayloadOffsetEnd;\n    var sizeDiff = offsetDiff + offsetEndDiff;\n    var refined = refineMetadata(payload, sizeDiff, info);\n    var newNewRefinedSize = new EBMLEncoder_1.default().encode(refined).byteLength; // 一旦 seekhead を作って自身のサイズを調べる\n    if (newNewRefinedSize === newPayloadSize) {\n      // Size is stable\n      return new EBMLEncoder_1.default().encode([].concat(ebml, [{\n        type: \"m\",\n        name: \"Segment\",\n        isEnd: false,\n        unknownSize: true\n      }], refined));\n    }\n    newPayloadSize = newNewRefinedSize;\n  }\n  throw new Error(\"unable to refine metadata, stable size could not be found in \" + i + \" iterations!\");\n}\nexports.putRefinedMetaData = putRefinedMetaData;\n// Given a list of EBMLElementBuffers, returns their encoded size in bytes\nfunction encodedSizeOfEbml(refinedMetaData) {\n  var encorder = new EBMLEncoder_1.default();\n  return refinedMetaData.reduce(function (lst, elm) {\n    return lst.concat(encorder.encode([elm]));\n  }, []).reduce(function (o, buf) {\n    return o + buf.byteLength;\n  }, 0);\n}\nfunction refineMetadata(mesetadata, sizeDiff, info) {\n  var duration = info.duration,\n    clusterPtrs = info.clusterPtrs,\n    cues = info.cues;\n  var _metadata = mesetadata.slice(0);\n  if (typeof duration === \"number\") {\n    // duration を追加する\n    var overwrited_1 = false;\n    _metadata.forEach(function (elm) {\n      if (elm.type === \"f\" && elm.name === \"Duration\") {\n        overwrited_1 = true;\n        elm.data = createFloatBuffer(duration, 8);\n      }\n    });\n    if (!overwrited_1) {\n      insertTag(_metadata, \"Info\", [{\n        name: \"Duration\",\n        type: \"f\",\n        data: createFloatBuffer(duration, 8)\n      }]);\n    }\n  }\n  if (Array.isArray(cues)) {\n    insertTag(_metadata, \"Cues\", create_cue(cues, sizeDiff));\n  }\n  var seekhead_children = [];\n  if (Array.isArray(clusterPtrs)) {\n    console.warn(\"append cluster pointers to seekhead is deprecated. please use cues\");\n    seekhead_children = create_seek_from_clusters(clusterPtrs, sizeDiff);\n  }\n  // remove seek info\n  /*\n  _metadata = _metadata.filter((elm)=> !(\n    elm.name === \"Seek\" ||\n    elm.name === \"SeekID\" ||\n    elm.name === \"SeekPosition\") );\n  */\n  // working on progress\n  //seekhead_children = seekhead_children.concat(create_seekhead(_metadata));\n  insertTag(_metadata, \"SeekHead\", seekhead_children, true);\n  return _metadata;\n}\nfunction create_seekhead(metadata, sizeDiff) {\n  var seeks = [];\n  [\"Info\", \"Tracks\", \"Cues\"].forEach(function (tagName) {\n    var tagStarts = metadata.filter(function (elm) {\n      return elm.type === \"m\" && elm.name === tagName && elm.isEnd === false;\n    }).map(function (elm) {\n      return elm[\"tagStart\"];\n    });\n    var tagStart = tagStarts[0];\n    if (typeof tagStart !== \"number\") {\n      return;\n    }\n    seeks.push({\n      name: \"Seek\",\n      type: \"m\",\n      isEnd: false\n    });\n    switch (tagName) {\n      case \"Info\":\n        seeks.push({\n          name: \"SeekID\",\n          type: \"b\",\n          data: new exports.Buffer([0x15, 0x49, 0xA9, 0x66])\n        });\n        break;\n      case \"Tracks\":\n        seeks.push({\n          name: \"SeekID\",\n          type: \"b\",\n          data: new exports.Buffer([0x16, 0x54, 0xAE, 0x6B])\n        });\n        break;\n      case \"Cues\":\n        seeks.push({\n          name: \"SeekID\",\n          type: \"b\",\n          data: new exports.Buffer([0x1C, 0x53, 0xBB, 0x6B])\n        });\n        break;\n    }\n    seeks.push({\n      name: \"SeekPosition\",\n      type: \"u\",\n      data: createUIntBuffer(tagStart + sizeDiff)\n    });\n    seeks.push({\n      name: \"Seek\",\n      type: \"m\",\n      isEnd: true\n    });\n  });\n  return seeks;\n}\nfunction create_seek_from_clusters(clusterPtrs, sizeDiff) {\n  var seeks = [];\n  clusterPtrs.forEach(function (start) {\n    seeks.push({\n      name: \"Seek\",\n      type: \"m\",\n      isEnd: false\n    });\n    // [0x1F, 0x43, 0xB6, 0x75] で Cluster 意\n    seeks.push({\n      name: \"SeekID\",\n      type: \"b\",\n      data: new exports.Buffer([0x1F, 0x43, 0xB6, 0x75])\n    });\n    seeks.push({\n      name: \"SeekPosition\",\n      type: \"u\",\n      data: createUIntBuffer(start + sizeDiff)\n    });\n    seeks.push({\n      name: \"Seek\",\n      type: \"m\",\n      isEnd: true\n    });\n  });\n  return seeks;\n}\nfunction create_cue(cueInfos, sizeDiff) {\n  var cues = [];\n  cueInfos.forEach(function (_a) {\n    var CueTrack = _a.CueTrack,\n      CueClusterPosition = _a.CueClusterPosition,\n      CueTime = _a.CueTime;\n    cues.push({\n      name: \"CuePoint\",\n      type: \"m\",\n      isEnd: false\n    });\n    cues.push({\n      name: \"CueTime\",\n      type: \"u\",\n      data: createUIntBuffer(CueTime)\n    });\n    cues.push({\n      name: \"CueTrackPositions\",\n      type: \"m\",\n      isEnd: false\n    });\n    cues.push({\n      name: \"CueTrack\",\n      type: \"u\",\n      data: createUIntBuffer(CueTrack)\n    }); // video track\n    cues.push({\n      name: \"CueClusterPosition\",\n      type: \"u\",\n      data: createUIntBuffer(CueClusterPosition + sizeDiff)\n    });\n    cues.push({\n      name: \"CueTrackPositions\",\n      type: \"m\",\n      isEnd: true\n    });\n    cues.push({\n      name: \"CuePoint\",\n      type: \"m\",\n      isEnd: true\n    });\n  });\n  return cues;\n}\nfunction insertTag(_metadata, tagName, children, insertHead) {\n  if (insertHead === void 0) {\n    insertHead = false;\n  }\n  // find the tagname from _metadata\n  var idx = -1;\n  for (var i = 0; i < _metadata.length; i++) {\n    var elm = _metadata[i];\n    if (elm.type === \"m\" && elm.name === tagName && elm.isEnd === false) {\n      idx = i;\n      break;\n    }\n  }\n  if (idx >= 0) {\n    // insert [<CuePoint />] to <Cues />\n    Array.prototype.splice.apply(_metadata, [idx + 1, 0].concat(children));\n  } else if (insertHead) {\n    [].concat([{\n      name: tagName,\n      type: \"m\",\n      isEnd: false\n    }], children, [{\n      name: tagName,\n      type: \"m\",\n      isEnd: true\n    }]).reverse().forEach(function (elm) {\n      _metadata.unshift(elm);\n    });\n  } else {\n    // metadata 末尾に <Cues /> を追加\n    // insert <Cues />\n    _metadata.push({\n      name: tagName,\n      type: \"m\",\n      isEnd: false\n    });\n    children.forEach(function (elm) {\n      _metadata.push(elm);\n    });\n    _metadata.push({\n      name: tagName,\n      type: \"m\",\n      isEnd: true\n    });\n  }\n}\n// alter Buffer.concat - https://github.com/feross/buffer/issues/154\nfunction concat(list) {\n  //return Buffer.concat.apply(Buffer, list);\n  var i = 0;\n  var length = 0;\n  for (; i < list.length; ++i) {\n    length += list[i].length;\n  }\n  var buffer = exports.Buffer.allocUnsafe(length);\n  var pos = 0;\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n}\nexports.concat = concat;\nfunction encodeValueToBuffer(elm) {\n  var data = new exports.Buffer(0);\n  if (elm.type === \"m\") {\n    return elm;\n  }\n  switch (elm.type) {\n    case \"u\":\n      data = createUIntBuffer(elm.value);\n      break;\n    case \"i\":\n      data = createIntBuffer(elm.value);\n      break;\n    case \"f\":\n      data = createFloatBuffer(elm.value);\n      break;\n    case \"s\":\n      data = new exports.Buffer(elm.value, 'ascii');\n      break;\n    case \"8\":\n      data = new exports.Buffer(elm.value, 'utf8');\n      break;\n    case \"b\":\n      data = elm.value;\n      break;\n    case \"d\":\n      data = new int64_buffer_1.Int64BE(elm.value.getTime().toString()).toBuffer();\n      break;\n  }\n  return Object.assign({}, elm, {\n    data: data\n  });\n}\nexports.encodeValueToBuffer = encodeValueToBuffer;\nfunction createUIntBuffer(value) {\n  // Big-endian, any size from 1 to 8\n  // but js number is float64, so max 6 bit octets\n  var bytes = 1;\n  for (; value >= Math.pow(2, 8 * bytes); bytes++) {}\n  if (bytes >= 7) {\n    console.warn(\"7bit or more bigger uint not supported.\");\n    return new int64_buffer_1.Uint64BE(value).toBuffer();\n  }\n  var data = new exports.Buffer(bytes);\n  data.writeUIntBE(value, 0, bytes);\n  return data;\n}\nexports.createUIntBuffer = createUIntBuffer;\nfunction createIntBuffer(value) {\n  // Big-endian, any size from 1 to 8 octets\n  // but js number is float64, so max 6 bit\n  var bytes = 1;\n  for (; value >= Math.pow(2, 8 * bytes); bytes++) {}\n  if (bytes >= 7) {\n    console.warn(\"7bit or more bigger uint not supported.\");\n    return new int64_buffer_1.Int64BE(value).toBuffer();\n  }\n  var data = new exports.Buffer(bytes);\n  data.writeIntBE(value, 0, bytes);\n  return data;\n}\nexports.createIntBuffer = createIntBuffer;\nfunction createFloatBuffer(value, bytes) {\n  if (bytes === void 0) {\n    bytes = 8;\n  }\n  // Big-endian, defined for 4 and 8 octets (32, 64 bits)\n  // js number is float64 so 8 bytes.\n  if (bytes === 8) {\n    // 64bit\n    var data = new exports.Buffer(8);\n    data.writeDoubleBE(value, 0);\n    return data;\n  } else if (bytes === 4) {\n    // 32bit\n    var data = new exports.Buffer(4);\n    data.writeFloatBE(value, 0);\n    return data;\n  } else {\n    throw new Error(\"float type bits must 4bytes or 8bytes\");\n  }\n}\nexports.createFloatBuffer = createFloatBuffer;\nfunction convertEBMLDateToJSDate(int64str) {\n  if (int64str instanceof Date) {\n    return int64str;\n  }\n  return new Date(new Date(\"2001-01-01T00:00:00.000Z\").getTime() + Number(int64str) / 1000 / 1000);\n}\nexports.convertEBMLDateToJSDate = convertEBMLDateToJSDate;","map":{"version":3,"names":["Object","defineProperty","exports","value","int64_buffer_1","require","EBMLEncoder_1","_Buffer","_tools","_block","Buffer","readVint","writeVint","ebmlBlock","readBlock","buf","encodeTag","tagId","tagData","unknownSize","concat","length","WebPFrameFilter","elms","WebPBlockFilter","reduce","lst","elm","o","data","frames","frame","webpBuf","VP8BitStreamToRiffWebPBuffer","webp","Blob","type","name","hasWebP","some","startcode","slice","toString","VP8Chunk","createRIFFChunk","WebPChunk","FourCC","chunk","chunkSize","writeUInt32LE","byteLength","substr","makeMetadataSeekable","originalMetadata","duration","cuesInfo","header","extractElement","headerSize","encodedSizeOfEbml","segmentContentStartPos","originalMetadataSize","dataEnd","info","removeElement","splice","createFloatBuffer","infoSize","tracks","tracksSize","seekHeadSize","seekHead","cuesSize","cues","lastSizeDifference","maxIterations","_loop_1","i","infoStart","tracksStart","cuesStart","newMetadataSize","sizeDifference","push","isEnd","createUIntBuffer","forEach","_a","CueTrack","CueClusterPosition","CueTime","Error","state_1","finalMetadata","apply","result","default","encode","idName","metadata","start","element","putRefinedMetaData","Array","isArray","cueInfos","console","warn","ebml","payload","i_1","shift","originalPayloadOffsetEnd","ebmlSize","refinedEBMLSize","offsetDiff","payloadSize","tagStart","segmentSize","segmentOffset","segmentTagBuf","segmentSizeBuf","_segmentSize","newPayloadSize","newPayloadOffsetEnd","offsetEndDiff","sizeDiff","refined","refineMetadata","newNewRefinedSize","refinedMetaData","encorder","mesetadata","clusterPtrs","_metadata","overwrited_1","insertTag","create_cue","seekhead_children","create_seek_from_clusters","create_seekhead","seeks","tagName","tagStarts","filter","map","children","insertHead","idx","prototype","reverse","unshift","list","buffer","allocUnsafe","pos","copy","encodeValueToBuffer","createIntBuffer","Int64BE","getTime","toBuffer","assign","bytes","Math","pow","Uint64BE","writeUIntBE","writeIntBE","writeDoubleBE","writeFloatBE","convertEBMLDateToJSDate","int64str","Date","Number"],"sources":["/Users/ruchireddy/trick-tracker/frontend/node_modules/ts-ebml/lib/tools.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/// <reference types=\"node\"/>\nvar int64_buffer_1 = require(\"int64-buffer\");\nvar EBMLEncoder_1 = require(\"./EBMLEncoder\");\nvar _Buffer = require(\"buffer/\");\nvar _tools = require(\"ebml/lib/ebml/tools\");\nvar _block = require(\"ebml-block\");\nexports.Buffer = _Buffer.Buffer;\nexports.readVint = _tools.readVint;\nexports.writeVint = _tools.writeVint;\nexports.ebmlBlock = _block;\nfunction readBlock(buf) {\n    return exports.ebmlBlock(new exports.Buffer(buf));\n}\nexports.readBlock = readBlock;\n/**\n  * @param end - if end === false then length is unknown\n  */\nfunction encodeTag(tagId, tagData, unknownSize) {\n    if (unknownSize === void 0) { unknownSize = false; }\n    return concat([\n        tagId,\n        unknownSize ?\n            new exports.Buffer('01ffffffffffffff', 'hex') :\n            exports.writeVint(tagData.length),\n        tagData\n    ]);\n}\nexports.encodeTag = encodeTag;\n/**\n * @return - SimpleBlock to WebP Filter\n */\nfunction WebPFrameFilter(elms) {\n    return WebPBlockFilter(elms).reduce(function (lst, elm) {\n        var o = exports.ebmlBlock(elm.data);\n        return o.frames.reduce(function (lst, frame) {\n            // https://developers.Blob.com/speed/webp/docs/riff_container\n            var webpBuf = VP8BitStreamToRiffWebPBuffer(frame);\n            var webp = new Blob([webpBuf], { type: \"image/webp\" });\n            return lst.concat(webp);\n        }, lst);\n    }, []);\n}\nexports.WebPFrameFilter = WebPFrameFilter;\n/**\n * WebP ファイルにできる SimpleBlock の パスフィルタ\n */\nfunction WebPBlockFilter(elms) {\n    return elms.reduce(function (lst, elm) {\n        if (elm.type !== \"b\") {\n            return lst;\n        }\n        if (elm.name !== \"SimpleBlock\") {\n            return lst;\n        }\n        var o = exports.ebmlBlock(elm.data);\n        var hasWebP = o.frames.some(function (frame) {\n            // https://tools.ietf.org/html/rfc6386#section-19.1\n            var startcode = frame.slice(3, 6).toString(\"hex\");\n            return startcode === \"9d012a\";\n        });\n        if (!hasWebP) {\n            return lst;\n        }\n        return lst.concat(elm);\n    }, []);\n}\nexports.WebPBlockFilter = WebPBlockFilter;\n/**\n * @param frame - VP8 BitStream のうち startcode をもつ frame\n * @return - WebP ファイルの ArrayBuffer\n */\nfunction VP8BitStreamToRiffWebPBuffer(frame) {\n    var VP8Chunk = createRIFFChunk(\"VP8 \", frame);\n    var WebPChunk = concat([\n        new exports.Buffer(\"WEBP\", \"ascii\"),\n        VP8Chunk\n    ]);\n    return createRIFFChunk(\"RIFF\", WebPChunk);\n}\nexports.VP8BitStreamToRiffWebPBuffer = VP8BitStreamToRiffWebPBuffer;\n/**\n * RIFF データチャンクを作る\n */\nfunction createRIFFChunk(FourCC, chunk) {\n    var chunkSize = new exports.Buffer(4);\n    chunkSize.writeUInt32LE(chunk.byteLength, 0);\n    return concat([\n        new exports.Buffer(FourCC.substr(0, 4), \"ascii\"),\n        chunkSize,\n        chunk,\n        new exports.Buffer(chunk.byteLength % 2 === 0 ? 0 : 1) // padding\n    ]);\n}\nexports.createRIFFChunk = createRIFFChunk;\n/* Original Metadata\n\n m  0\tEBML\n u  1\t  EBMLVersion 1\n u  1\t  EBMLReadVersion 1\n u  1\t  EBMLMaxIDLength 4\n u  1\t  EBMLMaxSizeLength 8\n s  1\t  DocType webm\n u  1\t  DocTypeVersion 4\n u  1\t  DocTypeReadVersion 2\n m  0\tSegment\n m  1\t  Info                                segmentContentStartPos, all CueClusterPositions provided in info.cues will be relative to here and will need adjusted\n u  2\t    TimecodeScale 1000000\n 8  2\t    MuxingApp Chrome\n 8  2\t    WritingApp Chrome\n m  1\t  Tracks                              tracksStartPos\n m  2\t    TrackEntry\n u  3\t      TrackNumber 1\n u  3\t      TrackUID 31790271978391090\n u  3\t      TrackType 2\n s  3\t      CodecID A_OPUS\n b  3\t      CodecPrivate <Buffer 19>\n m  3\t      Audio\n f  4\t        SamplingFrequency 48000\n u  4\t        Channels 1\n m  2\t    TrackEntry\n u  3\t      TrackNumber 2\n u  3\t      TrackUID 24051277436254136\n u  3\t      TrackType 1\n s  3\t      CodecID V_VP8\n m  3\t      Video\n u  4\t        PixelWidth 1024\n u  4\t        PixelHeight 576\n m  1\t  Cluster                             clusterStartPos\n u  2\t    Timecode 0\n b  2\t    SimpleBlock track:2 timecode:0\tkeyframe:true\tinvisible:false\tdiscardable:false\tlacing:1\n*/\n/* Desired Metadata\n\n m\t0 EBML\n u\t1   EBMLVersion 1\n u\t1   EBMLReadVersion 1\n u\t1   EBMLMaxIDLength 4\n u\t1   EBMLMaxSizeLength 8\n s\t1   DocType webm\n u\t1   DocTypeVersion 4\n u\t1   DocTypeReadVersion 2\n m\t0 Segment\n m\t1   SeekHead                            -> This is SeekPosition 0, so all SeekPositions can be calculated as (bytePos - segmentContentStartPos), which is 44 in this case\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x15, 0x49, 0xA9, 0x66])  Info\n u\t3       SeekPosition                    -> infoStartPos =\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x16, 0x54, 0xAE, 0x6B])  Tracks\n u\t3       SeekPosition { tracksStartPos }\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x1C, 0x53, 0xBB, 0x6B])  Cues\n u\t3       SeekPosition { cuesStartPos }\n m\t1   Info\n f\t2     Duration 32480                    -> overwrite, or insert if it doesn't exist\n u\t2     TimecodeScale 1000000\n 8\t2     MuxingApp Chrome\n 8\t2     WritingApp Chrome\n m\t1   Tracks\n m\t2     TrackEntry\n u\t3       TrackNumber 1\n u\t3       TrackUID 31790271978391090\n u\t3       TrackType 2\n s\t3       CodecID A_OPUS\n b\t3       CodecPrivate <Buffer 19>\n m\t3       Audio\n f\t4         SamplingFrequency 48000\n u\t4         Channels 1\n m\t2     TrackEntry\n u\t3       TrackNumber 2\n u\t3       TrackUID 24051277436254136\n u\t3       TrackType 1\n s\t3       CodecID V_VP8\n m\t3       Video\n u\t4         PixelWidth 1024\n u\t4         PixelHeight 576\n m  1   Cues                                -> cuesStartPos\n m  2     CuePoint\n u  3       CueTime 0\n m  3       CueTrackPositions\n u  4         CueTrack 1\n u  4         CueClusterPosition 3911\n m  2     CuePoint\n u  3       CueTime 600\n m  3       CueTrackPositions\n u  4         CueTrack 1\n u  4         CueClusterPosition 3911\n m  1   Cluster\n u  2     Timecode 0\n b  2     SimpleBlock track:2 timecode:0\tkeyframe:true\tinvisible:false\tdiscardable:false\tlacing:1\n*/\n/**\n * convert the metadata from a streaming webm bytestream to a seekable file by inserting Duration, Seekhead and Cues\n * @param originalMetadata - orginal metadata (everything before the clusters start) from media recorder\n * @param duration - Duration (TimecodeScale)\n * @param cues - cue points for clusters\n */\nfunction makeMetadataSeekable(originalMetadata, duration, cuesInfo) {\n    // extract the header, we can reuse this as-is\n    var header = extractElement(\"EBML\", originalMetadata);\n    var headerSize = encodedSizeOfEbml(header);\n    //console.error(\"Header size: \" + headerSize);\n    //printElementIds(header);\n    // After the header comes the Segment open tag, which in this implementation is always 12 bytes (4 byte id, 8 byte 'unknown length')\n    // After that the segment content starts. All SeekPositions and CueClusterPosition must be relative to segmentContentStartPos\n    var segmentContentStartPos = headerSize + 12;\n    //console.error(\"segmentContentStartPos: \" + segmentContentStartPos);    \n    // find the original metadata size, and adjust it for header size and Segment start element so we can keep all positions relative to segmentContentStartPos\n    var originalMetadataSize = originalMetadata[originalMetadata.length - 1].dataEnd - segmentContentStartPos;\n    //console.error(\"Original Metadata size: \" + originalMetadataSize);\n    //printElementIds(originalMetadata);\n    // extract the segment info, remove the potentially existing Duration element, and add our own one.\n    var info = extractElement(\"Info\", originalMetadata);\n    removeElement(\"Duration\", info);\n    info.splice(1, 0, { name: \"Duration\", type: \"f\", data: createFloatBuffer(duration, 8) });\n    var infoSize = encodedSizeOfEbml(info);\n    //console.error(\"Info size: \" + infoSize);\n    //printElementIds(info);  \n    // extract the track info, we can re-use this as is\n    var tracks = extractElement(\"Tracks\", originalMetadata);\n    var tracksSize = encodedSizeOfEbml(tracks);\n    //console.error(\"Tracks size: \" + tracksSize);\n    //printElementIds(tracks);  \n    var seekHeadSize = 47; // Initial best guess, but could be slightly larger if the Cues element is huge.\n    var seekHead = [];\n    var cuesSize = 5 + cuesInfo.length * 15; // very rough initial approximation, depends a lot on file size and number of CuePoints                   \n    var cues = [];\n    var lastSizeDifference = -1; // \n    // The size of SeekHead and Cues elements depends on how many bytes the offsets values can be encoded in.\n    // The actual offsets in CueClusterPosition depend on the final size of the SeekHead and Cues elements\n    // We need to iteratively converge to a stable solution.\n    var maxIterations = 10;\n    var _loop_1 = function (i) {\n        // SeekHead starts at 0\n        var infoStart = seekHeadSize; // Info comes directly after SeekHead\n        var tracksStart = infoStart + infoSize; // Tracks comes directly after Info\n        var cuesStart = tracksStart + tracksSize; // Cues starts directly after \n        var newMetadataSize = cuesStart + cuesSize; // total size of metadata  \n        // This is the offset all CueClusterPositions should be adjusted by due to the metadata size changing.\n        var sizeDifference = newMetadataSize - originalMetadataSize;\n        // console.error(`infoStart: ${infoStart}, infoSize: ${infoSize}`);\n        // console.error(`tracksStart: ${tracksStart}, tracksSize: ${tracksSize}`);\n        // console.error(`cuesStart: ${cuesStart}, cuesSize: ${cuesSize}`);\n        // console.error(`originalMetadataSize: ${originalMetadataSize}, newMetadataSize: ${newMetadataSize}, sizeDifference: ${sizeDifference}`); \n        // create the SeekHead element\n        seekHead = [];\n        seekHead.push({ name: \"SeekHead\", type: \"m\", isEnd: false });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: false });\n        seekHead.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x15, 0x49, 0xA9, 0x66]) }); // Info\n        seekHead.push({ name: \"SeekPosition\", type: \"u\", data: createUIntBuffer(infoStart) });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: true });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: false });\n        seekHead.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x16, 0x54, 0xAE, 0x6B]) }); // Tracks\n        seekHead.push({ name: \"SeekPosition\", type: \"u\", data: createUIntBuffer(tracksStart) });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: true });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: false });\n        seekHead.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x1C, 0x53, 0xBB, 0x6B]) }); // Cues\n        seekHead.push({ name: \"SeekPosition\", type: \"u\", data: createUIntBuffer(cuesStart) });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: true });\n        seekHead.push({ name: \"SeekHead\", type: \"m\", isEnd: true });\n        seekHeadSize = encodedSizeOfEbml(seekHead);\n        //console.error(\"SeekHead size: \" + seekHeadSize);\n        //printElementIds(seekHead);  \n        // create the Cues element\n        cues = [];\n        cues.push({ name: \"Cues\", type: \"m\", isEnd: false });\n        cuesInfo.forEach(function (_a) {\n            var CueTrack = _a.CueTrack, CueClusterPosition = _a.CueClusterPosition, CueTime = _a.CueTime;\n            cues.push({ name: \"CuePoint\", type: \"m\", isEnd: false });\n            cues.push({ name: \"CueTime\", type: \"u\", data: createUIntBuffer(CueTime) });\n            cues.push({ name: \"CueTrackPositions\", type: \"m\", isEnd: false });\n            cues.push({ name: \"CueTrack\", type: \"u\", data: createUIntBuffer(CueTrack) });\n            //console.error(`CueClusterPosition: ${CueClusterPosition}, Corrected to: ${CueClusterPosition - segmentContentStartPos}  , offset by ${sizeDifference} to become ${(CueClusterPosition - segmentContentStartPos) + sizeDifference - segmentContentStartPos}`);\n            // EBMLReader returns CueClusterPosition with absolute byte offsets. The Cues section expects them as offsets from the first level 1 element of the Segment, so we need to adjust it.\n            CueClusterPosition -= segmentContentStartPos;\n            // We also need to adjust to take into account the change in metadata size from when EBMLReader read the original metadata.\n            CueClusterPosition += sizeDifference;\n            cues.push({ name: \"CueClusterPosition\", type: \"u\", data: createUIntBuffer(CueClusterPosition) });\n            cues.push({ name: \"CueTrackPositions\", type: \"m\", isEnd: true });\n            cues.push({ name: \"CuePoint\", type: \"m\", isEnd: true });\n        });\n        cues.push({ name: \"Cues\", type: \"m\", isEnd: true });\n        cuesSize = encodedSizeOfEbml(cues);\n        //console.error(\"Cues size: \" + cuesSize);   \n        //console.error(\"Cue count: \" + cuesInfo.length);\n        //printElementIds(cues);      \n        // If the new MetadataSize is not the same as the previous iteration, we need to run once more.\n        if (lastSizeDifference !== sizeDifference) {\n            lastSizeDifference = sizeDifference;\n            if (i === maxIterations - 1) {\n                throw new Error(\"Failed to converge to a stable metadata size\");\n            }\n        }\n        else {\n            return \"break\";\n        }\n    };\n    for (var i = 0; i < maxIterations; i++) {\n        var state_1 = _loop_1(i);\n        if (state_1 === \"break\")\n            break;\n    }\n    var finalMetadata = [].concat.apply([], [\n        header,\n        { name: \"Segment\", type: \"m\", isEnd: false, unknownSize: true },\n        seekHead,\n        info,\n        tracks,\n        cues\n    ]);\n    var result = new EBMLEncoder_1.default().encode(finalMetadata);\n    //printElementIds(finalMetadata);\n    //console.error(`Final metadata buffer size: ${result.byteLength}`);\n    //console.error(`Final metadata buffer size without header and segment: ${result.byteLength-segmentContentStartPos}`);\n    return result;\n}\nexports.makeMetadataSeekable = makeMetadataSeekable;\n/**\n * print all element id names in a list\n\n * @param metadata - array of EBML elements to print\n *\nexport function printElementIds(metadata: EBML.EBMLElementBuffer[]) {\n\n  let result: EBML.EBMLElementBuffer[] = [];\n  let start: number = -1;\n\n  for (let i = 0; i < metadata.length; i++) {\n    console.error(\"\\t id: \" + metadata[i].name);\n  }\n}\n*/\n/**\n * remove all occurances of an EBML element from an array of elements\n * If it's a MasterElement you will also remove the content. (everything between start and end)\n * @param idName - name of the EBML Element to remove.\n * @param metadata - array of EBML elements to search\n */\nfunction removeElement(idName, metadata) {\n    var result = [];\n    var start = -1;\n    for (var i = 0; i < metadata.length; i++) {\n        var element = metadata[i];\n        if (element.name === idName) {\n            // if it's a Master element, extract the start and end element, and everything in between\n            if (element.type === \"m\") {\n                if (!element.isEnd) {\n                    start = i;\n                }\n                else {\n                    // we've reached the end, extract the whole thing\n                    if (start == -1)\n                        throw new Error(\"Detected \" + idName + \" closing element before finding the start\");\n                    metadata.splice(start, i - start + 1);\n                    return;\n                }\n            }\n            else {\n                // not a Master element, so we've found what we're looking for.\n                metadata.splice(i, 1);\n                return;\n            }\n        }\n    }\n}\nexports.removeElement = removeElement;\n/**\n * extract the first occurance of an EBML tag from a flattened array of EBML data.\n * If it's a MasterElement you will also get the content. (everything between start and end)\n * @param idName - name of the EBML Element to extract.\n * @param metadata - array of EBML elements to search\n */\nfunction extractElement(idName, metadata) {\n    var result = [];\n    var start = -1;\n    for (var i = 0; i < metadata.length; i++) {\n        var element = metadata[i];\n        if (element.name === idName) {\n            // if it's a Master element, extract the start and end element, and everything in between\n            if (element.type === \"m\") {\n                if (!element.isEnd) {\n                    start = i;\n                }\n                else {\n                    // we've reached the end, extract the whole thing\n                    if (start == -1)\n                        throw new Error(\"Detected \" + idName + \" closing element before finding the start\");\n                    result = metadata.slice(start, i + 1);\n                    break;\n                }\n            }\n            else {\n                // not a Master element, so we've found what we're looking for.\n                result.push(metadata[i]);\n                break;\n            }\n        }\n    }\n    return result;\n}\nexports.extractElement = extractElement;\n/**\n * @deprecated\n * metadata に対して duration と seekhead を追加した metadata を返す\n * @param metadata - 変更前の webm における ファイル先頭から 最初の Cluster 要素までの 要素\n * @param duration - Duration (TimecodeScale)\n * @param cues - cue points for clusters\n * @deprecated @param clusterPtrs - 変更前の webm における SeekHead に追加する Cluster 要素 への start pointer\n * @deprecated @param cueInfos - please use cues.\n */\nfunction putRefinedMetaData(metadata, info) {\n    if (Array.isArray(info.cueInfos) && !Array.isArray(info.cues)) {\n        console.warn(\"putRefinedMetaData: info.cueInfos property is deprecated. please use info.cues\");\n        info.cues = info.cueInfos;\n    }\n    var ebml = [];\n    var payload = [];\n    for (var i_1 = 0; i_1 < metadata.length; i_1++) {\n        var elm = metadata[i_1];\n        if (elm.type === \"m\" && elm.name === \"Segment\") {\n            ebml = metadata.slice(0, i_1);\n            payload = metadata.slice(i_1);\n            if (elm.unknownSize) {\n                payload.shift(); // remove segment tag\n                break;\n            }\n            throw new Error(\"this metadata is not streaming webm file\");\n        }\n    }\n    // *0    *4    *5  *36      *40   *48=segmentOffset              *185=originalPayloadOffsetEnd\n    // |     |     |   |        |     |                              |\n    // [EBML][size]....[Segment][size][Info][size][Duration][size]...[Cluster]\n    // |               |        |^inf |                              |\n    // |               +segmentSiz(12)+                              |\n    // +-ebmlSize(36)--+        |     +-payloadSize(137)-------------+offsetEndDiff+\n    //                 |        |     +-newPayloadSize(??)-------------------------+\n    //                 |        |     |                                            |\n    //                 [Segment][size][Info][size][Duration][size]....[size][value][Cluster]\n    //                           ^                                                 |\n    //                           |                                                 *??=newPayloadOffsetEnd\n    //                           inf\n    if (!(payload[payload.length - 1].dataEnd > 0)) {\n        throw new Error(\"metadata dataEnd has wrong number\");\n    }\n    var originalPayloadOffsetEnd = payload[payload.length - 1].dataEnd; // = first cluster ptr\n    var ebmlSize = ebml[ebml.length - 1].dataEnd; // = first segment ptr\n    var refinedEBMLSize = new EBMLEncoder_1.default().encode(ebml).byteLength;\n    var offsetDiff = refinedEBMLSize - ebmlSize;\n    var payloadSize = originalPayloadOffsetEnd - payload[0].tagStart;\n    var segmentSize = payload[0].tagStart - ebmlSize;\n    var segmentOffset = payload[0].tagStart;\n    var segmentTagBuf = new exports.Buffer([0x18, 0x53, 0x80, 0x67]); // Segment\n    var segmentSizeBuf = new exports.Buffer('01ffffffffffffff', 'hex'); // Segmentの最後の位置は無数の Cluster 依存なので。 writeVint(newPayloadSize).byteLength ではなく、 infinity.\n    var _segmentSize = segmentTagBuf.byteLength + segmentSizeBuf.byteLength; // == segmentSize\n    var newPayloadSize = payloadSize;\n    // We need the size to be stable between two refinements in order for our offsets to be correct\n    // Bound the number of possible refinements so we can't go infinate if something goes wrong\n    var i;\n    for (i = 1; i < 20; i++) {\n        var newPayloadOffsetEnd = ebmlSize + _segmentSize + newPayloadSize;\n        var offsetEndDiff = newPayloadOffsetEnd - originalPayloadOffsetEnd;\n        var sizeDiff = offsetDiff + offsetEndDiff;\n        var refined = refineMetadata(payload, sizeDiff, info);\n        var newNewRefinedSize = new EBMLEncoder_1.default().encode(refined).byteLength; // 一旦 seekhead を作って自身のサイズを調べる\n        if (newNewRefinedSize === newPayloadSize) {\n            // Size is stable\n            return new EBMLEncoder_1.default().encode([].concat(ebml, [{ type: \"m\", name: \"Segment\", isEnd: false, unknownSize: true }], refined));\n        }\n        newPayloadSize = newNewRefinedSize;\n    }\n    throw new Error(\"unable to refine metadata, stable size could not be found in \" + i + \" iterations!\");\n}\nexports.putRefinedMetaData = putRefinedMetaData;\n// Given a list of EBMLElementBuffers, returns their encoded size in bytes\nfunction encodedSizeOfEbml(refinedMetaData) {\n    var encorder = new EBMLEncoder_1.default();\n    return refinedMetaData.reduce(function (lst, elm) { return lst.concat(encorder.encode([elm])); }, []).reduce(function (o, buf) { return o + buf.byteLength; }, 0);\n}\nfunction refineMetadata(mesetadata, sizeDiff, info) {\n    var duration = info.duration, clusterPtrs = info.clusterPtrs, cues = info.cues;\n    var _metadata = mesetadata.slice(0);\n    if (typeof duration === \"number\") {\n        // duration を追加する\n        var overwrited_1 = false;\n        _metadata.forEach(function (elm) {\n            if (elm.type === \"f\" && elm.name === \"Duration\") {\n                overwrited_1 = true;\n                elm.data = createFloatBuffer(duration, 8);\n            }\n        });\n        if (!overwrited_1) {\n            insertTag(_metadata, \"Info\", [{ name: \"Duration\", type: \"f\", data: createFloatBuffer(duration, 8) }]);\n        }\n    }\n    if (Array.isArray(cues)) {\n        insertTag(_metadata, \"Cues\", create_cue(cues, sizeDiff));\n    }\n    var seekhead_children = [];\n    if (Array.isArray(clusterPtrs)) {\n        console.warn(\"append cluster pointers to seekhead is deprecated. please use cues\");\n        seekhead_children = create_seek_from_clusters(clusterPtrs, sizeDiff);\n    }\n    // remove seek info\n    /*\n    _metadata = _metadata.filter((elm)=> !(\n      elm.name === \"Seek\" ||\n      elm.name === \"SeekID\" ||\n      elm.name === \"SeekPosition\") );\n    */\n    // working on progress\n    //seekhead_children = seekhead_children.concat(create_seekhead(_metadata));\n    insertTag(_metadata, \"SeekHead\", seekhead_children, true);\n    return _metadata;\n}\nfunction create_seekhead(metadata, sizeDiff) {\n    var seeks = [];\n    [\"Info\", \"Tracks\", \"Cues\"].forEach(function (tagName) {\n        var tagStarts = metadata.filter(function (elm) { return elm.type === \"m\" && elm.name === tagName && elm.isEnd === false; }).map(function (elm) { return elm[\"tagStart\"]; });\n        var tagStart = tagStarts[0];\n        if (typeof tagStart !== \"number\") {\n            return;\n        }\n        seeks.push({ name: \"Seek\", type: \"m\", isEnd: false });\n        switch (tagName) {\n            case \"Info\":\n                seeks.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x15, 0x49, 0xA9, 0x66]) });\n                break;\n            case \"Tracks\":\n                seeks.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x16, 0x54, 0xAE, 0x6B]) });\n                break;\n            case \"Cues\":\n                seeks.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x1C, 0x53, 0xBB, 0x6B]) });\n                break;\n        }\n        seeks.push({ name: \"SeekPosition\", type: \"u\", data: createUIntBuffer(tagStart + sizeDiff) });\n        seeks.push({ name: \"Seek\", type: \"m\", isEnd: true });\n    });\n    return seeks;\n}\nfunction create_seek_from_clusters(clusterPtrs, sizeDiff) {\n    var seeks = [];\n    clusterPtrs.forEach(function (start) {\n        seeks.push({ name: \"Seek\", type: \"m\", isEnd: false });\n        // [0x1F, 0x43, 0xB6, 0x75] で Cluster 意\n        seeks.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x1F, 0x43, 0xB6, 0x75]) });\n        seeks.push({ name: \"SeekPosition\", type: \"u\", data: createUIntBuffer(start + sizeDiff) });\n        seeks.push({ name: \"Seek\", type: \"m\", isEnd: true });\n    });\n    return seeks;\n}\nfunction create_cue(cueInfos, sizeDiff) {\n    var cues = [];\n    cueInfos.forEach(function (_a) {\n        var CueTrack = _a.CueTrack, CueClusterPosition = _a.CueClusterPosition, CueTime = _a.CueTime;\n        cues.push({ name: \"CuePoint\", type: \"m\", isEnd: false });\n        cues.push({ name: \"CueTime\", type: \"u\", data: createUIntBuffer(CueTime) });\n        cues.push({ name: \"CueTrackPositions\", type: \"m\", isEnd: false });\n        cues.push({ name: \"CueTrack\", type: \"u\", data: createUIntBuffer(CueTrack) }); // video track\n        cues.push({ name: \"CueClusterPosition\", type: \"u\", data: createUIntBuffer(CueClusterPosition + sizeDiff) });\n        cues.push({ name: \"CueTrackPositions\", type: \"m\", isEnd: true });\n        cues.push({ name: \"CuePoint\", type: \"m\", isEnd: true });\n    });\n    return cues;\n}\nfunction insertTag(_metadata, tagName, children, insertHead) {\n    if (insertHead === void 0) { insertHead = false; }\n    // find the tagname from _metadata\n    var idx = -1;\n    for (var i = 0; i < _metadata.length; i++) {\n        var elm = _metadata[i];\n        if (elm.type === \"m\" && elm.name === tagName && elm.isEnd === false) {\n            idx = i;\n            break;\n        }\n    }\n    if (idx >= 0) {\n        // insert [<CuePoint />] to <Cues />\n        Array.prototype.splice.apply(_metadata, [idx + 1, 0].concat(children));\n    }\n    else if (insertHead) {\n        [].concat([{ name: tagName, type: \"m\", isEnd: false }], children, [{ name: tagName, type: \"m\", isEnd: true }]).reverse().forEach(function (elm) { _metadata.unshift(elm); });\n    }\n    else {\n        // metadata 末尾に <Cues /> を追加\n        // insert <Cues />\n        _metadata.push({ name: tagName, type: \"m\", isEnd: false });\n        children.forEach(function (elm) { _metadata.push(elm); });\n        _metadata.push({ name: tagName, type: \"m\", isEnd: true });\n    }\n}\n// alter Buffer.concat - https://github.com/feross/buffer/issues/154\nfunction concat(list) {\n    //return Buffer.concat.apply(Buffer, list);\n    var i = 0;\n    var length = 0;\n    for (; i < list.length; ++i) {\n        length += list[i].length;\n    }\n    var buffer = exports.Buffer.allocUnsafe(length);\n    var pos = 0;\n    for (i = 0; i < list.length; ++i) {\n        var buf = list[i];\n        buf.copy(buffer, pos);\n        pos += buf.length;\n    }\n    return buffer;\n}\nexports.concat = concat;\nfunction encodeValueToBuffer(elm) {\n    var data = new exports.Buffer(0);\n    if (elm.type === \"m\") {\n        return elm;\n    }\n    switch (elm.type) {\n        case \"u\":\n            data = createUIntBuffer(elm.value);\n            break;\n        case \"i\":\n            data = createIntBuffer(elm.value);\n            break;\n        case \"f\":\n            data = createFloatBuffer(elm.value);\n            break;\n        case \"s\":\n            data = new exports.Buffer(elm.value, 'ascii');\n            break;\n        case \"8\":\n            data = new exports.Buffer(elm.value, 'utf8');\n            break;\n        case \"b\":\n            data = elm.value;\n            break;\n        case \"d\":\n            data = new int64_buffer_1.Int64BE(elm.value.getTime().toString()).toBuffer();\n            break;\n    }\n    return Object.assign({}, elm, { data: data });\n}\nexports.encodeValueToBuffer = encodeValueToBuffer;\nfunction createUIntBuffer(value) {\n    // Big-endian, any size from 1 to 8\n    // but js number is float64, so max 6 bit octets\n    var bytes = 1;\n    for (; value >= Math.pow(2, 8 * bytes); bytes++) { }\n    if (bytes >= 7) {\n        console.warn(\"7bit or more bigger uint not supported.\");\n        return new int64_buffer_1.Uint64BE(value).toBuffer();\n    }\n    var data = new exports.Buffer(bytes);\n    data.writeUIntBE(value, 0, bytes);\n    return data;\n}\nexports.createUIntBuffer = createUIntBuffer;\nfunction createIntBuffer(value) {\n    // Big-endian, any size from 1 to 8 octets\n    // but js number is float64, so max 6 bit\n    var bytes = 1;\n    for (; value >= Math.pow(2, 8 * bytes); bytes++) { }\n    if (bytes >= 7) {\n        console.warn(\"7bit or more bigger uint not supported.\");\n        return new int64_buffer_1.Int64BE(value).toBuffer();\n    }\n    var data = new exports.Buffer(bytes);\n    data.writeIntBE(value, 0, bytes);\n    return data;\n}\nexports.createIntBuffer = createIntBuffer;\nfunction createFloatBuffer(value, bytes) {\n    if (bytes === void 0) { bytes = 8; }\n    // Big-endian, defined for 4 and 8 octets (32, 64 bits)\n    // js number is float64 so 8 bytes.\n    if (bytes === 8) {\n        // 64bit\n        var data = new exports.Buffer(8);\n        data.writeDoubleBE(value, 0);\n        return data;\n    }\n    else if (bytes === 4) {\n        // 32bit\n        var data = new exports.Buffer(4);\n        data.writeFloatBE(value, 0);\n        return data;\n    }\n    else {\n        throw new Error(\"float type bits must 4bytes or 8bytes\");\n    }\n}\nexports.createFloatBuffer = createFloatBuffer;\nfunction convertEBMLDateToJSDate(int64str) {\n    if (int64str instanceof Date) {\n        return int64str;\n    }\n    return new Date(new Date(\"2001-01-01T00:00:00.000Z\").getTime() + (Number(int64str) / 1000 / 1000));\n}\nexports.convertEBMLDateToJSDate = convertEBMLDateToJSDate;\n"],"mappings":"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AAC;EACF,OAAOC,eAAe,CAAC,MAAM,EAAEC,SAAS,CAAC;AAC7C;AACA3C,OAAO,CAAC+B,4BAA4B,GAAGA,4BAA4B;AACnE;AACA;AACA;AACA,SAASW,eAAeA,CAACE,MAAM,EAAEC,KAAK,EAAE;EACpC,IAAIC,SAAS,GAAG,IAAI9C,OAAO,CAACQ,MAAM,CAAC,CAAC,CAAC;EACrCsC,SAAS,CAACC,aAAa,CAACF,KAAK,CAACG,UAAU,EAAE,CAAC,CAAC;EAC5C,OAAO9B,MAAM,CAAC,CACV,IAAIlB,OAAO,CAACQ,MAAM,CAACoC,MAAM,CAACK,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,OAAO,CAAC,EAChDH,SAAS,EACTD,KAAK,EACL,IAAI7C,OAAO,CAACQ,MAAM,CAACqC,KAAK,CAACG,UAAU,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;EAAA,CAC1D,CAAC;AACN;;AACAhD,OAAO,CAAC0C,eAAe,GAAGA,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASQ,oBAAoBA,CAACC,gBAAgB,EAAEC,QAAQ,EAAEC,QAAQ,EAAE;EAChE;EACA,IAAIC,MAAM,GAAGC,cAAc,CAAC,MAAM,EAAEJ,gBAAgB,CAAC;EA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"},"metadata":{},"sourceType":"script","externalDependencies":[]}